
"""
    x, val = optim_wrap(f, x0 / gen, mapin;
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options(),
    n_starts = 0)

A wrapper for `Optim`.  
Adds a few features that I find helpful, especially when I want to optimize over a manifold or odd parameter space.
The function `mapin` should take an aribtrary vector (or matrix) input and map it to the space of interest.
`mapin` will always be applied before `f`.

As `mapin` can do strange things to the vector, `Optim` might not be working in the right parameter space.
For this reason, it is helpful to occasionally stop optim, apply `mapin` to the current optimum,
and then restart `Optim` from that point.
This code does this `nrounds` times.
If it seems unnecessary, say if `mapin = identity`, then set `nrounds=1`.

As `Optim` can run for a while, we might be able to improve it by starting from the best of many inputs.
If `n_starts > 1`, the code will call `gen` to generate `n_starts` and then start `Optim` from the best of these.

# Arguments
- `f` is a nonlinear func to optimize
- `x0` is an initial point. Instead of being a vector, it can be a generator like `()->rand(3)`
- `mapin` is a function applied to things like `x` to put in range.
- We run for `nrounds`, with a `mapin `at the end of each to polish.
- The `n_starts` option then tells us to start from the best of `n_starts`runs.
- `optfunc` is the name of an optimizer that Optim uses.
- `options` are options for Optim, with the default generated by `Optim.Options()`.
"""
function optim_wrap(f, x0::Array, mapin;
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options())

    @assert sense==:Max || sense==:Min

    if sense == :Max
        sgn = -1
        comp = >
    else
         sgn = 1
        comp = <
    end

    x0 = mapin(x0)
    fixed_f(z) = f(mapin(z))
    f_opt(z) = sgn*fixed_f(z)

    local val
    for i in 1:nrounds
        opt = Optim.optimize(f_opt, x0, optfunc , options)
        best = opt.minimizer
        val = fixed_f(best)
        x0 = mapin(best)
    end

    return x0, val
end

function optim_wrap(f, gen::Function, mapin;
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options(),
    n_starts = 0)

    fixed_f(z) = f(mapin(z))

    if n_starts > 1 
        x0, _  = try_many(fixed_f, gen, sense, n_tries = n_starts, verbosity=0)
    else
        x0 = gen()
    end 

    optim_wrap(f, x0, mapin,
        nrounds=nrounds,
        optfunc=optfunc,
        sense=sense,
        options=options)
end




"""
    x, val = optim_wrap_many(f, x0, mapin; n_tries = Inf, t_lim = Inf,
        stop_val, 
        nrounds=3,
        optfunc=NelderMead(),
        sense = :Max,
        options = Optim.Options(),
        n_starts = 0,
        par_batch = 0,
        threads = 0,
        stop_val = Inf for -Inf depending on sense)

    val, best = optim_wrap_many(f, x0fun, mapin, n_tries;
    nrounds, optfunc, maxevals, sense,
    file=[])

Call `optim_wrap` inside `try_many`. Kwargs come from both.
At least one of `n_tries` or `t_lim` must be set.
"""
function optim_wrap_many(f::Function, gen::Function, mapin;  n_tries = Inf, t_lim = Inf,
    file_base = "",
    verbose = false,
    verbosity = 1 + verbose,
    seed = false,
    local_rng = false,
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options(),
    n_starts = 0,
    par_batch = 0,
    threads = 0,
    stop_val = sense == :Max ? Inf : -Inf)

    if t_lim < Inf
        tdo = Dict(fn=>getfield(options, fn) for fn âˆˆ fieldnames(typeof(options)))
        tdo[:time_limit] = t_lim
        options = Optim.Options(;tdo...)
    end

    fsub(x) = optim_wrap(f, gen, mapin,
        nrounds=nrounds,
        optfunc=optfunc,
        sense = sense,
        options = options,
        n_starts = n_starts)

    # if t_lim, put that into options

    return try_many_trans(fsub, ()->Nothing, sense, n_tries = n_tries, t_lim = t_lim,
        file_base = file_base,
        verbosity = verbosity,
        seed = seed,
        local_rng = local_rng,
        par_batch = par_batch,
        threads = threads,
        stop_val = stop_val)


end
