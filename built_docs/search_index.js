var documenterSearchIndex = {"docs":
[{"location":"index.html#DASopt.jl","page":"DASopt.jl","title":"DASopt.jl","text":"","category":"section"},{"location":"index.html#The-optimization-wrappers","page":"DASopt.jl","title":"The optimization wrappers","text":"","category":"section"},{"location":"index.html","page":"DASopt.jl","title":"DASopt.jl","text":"try_many is designed to evaluate a function on many random inputs.\noptim_wrap is a wrapper around Optim.\noptim_wrap_many uses try_many to call optim_wrap from many random initial points.","category":"page"},{"location":"index.html","page":"DASopt.jl","title":"DASopt.jl","text":"To the extent that parameters of optim_wrap_many are inherited from optim_wrap and try_many, they are described in those routines.","category":"page"},{"location":"index.html","page":"DASopt.jl","title":"DASopt.jl","text":"try_many\noptim_wrap\noptim_wrap_many","category":"page"},{"location":"index.html#DASopt.try_many","page":"DASopt.jl","title":"DASopt.try_many","text":"x, val = try_many(obj::Function, gen::Function, sense::Symbol; n_tries = Inf, t_lim = Inf, ...\n\nReturn the best of many calls of obj on the output of gen, where best is according to sense which should be :Max or :Min. Repeats for n_tries trials or until t_lim seconds pass.  One of these must be set.\n\nArguments\n\nobj::Function: The objective function\ngen::Function: A zero-argument function. gen() should generate an input to obj.  For example, ()->rand(4).\nsense::Symbol: :Min or :Max\nn::Integer: An upper bound on the number of inputs to try.\nt_lim: Will stop after t_lim seconds.\nfn_base: if this is non-empty, then output will be saved to $(fn_base).txt and $(fn_base).jld.\nverbosity::Integer: if 0, should be no output.   1, will output just the best so far each time a new one is found.   2, will output everything.\nseed::Bool: if negative, nothing happens.  Otherwise, seed the ith trial with the ith random seed.\nlocal_rng::Bool: if true, gen() should take a RNG as input, and it will be seeded as suggested by seed. This prevents the gen erator for instances from intefering with any generator the algorithm might use.\nverbose::Bool: for backwards compatibility.  Used to set verbosity.\npar_batch::Integer: if 0, don't parallelize. If > 0, run in batches of this size.   Will force seed, unless using localrng.  localrng parallelizes the time of generation.\nstop_val: will stop as soon as find a value better than this\n\n\n\n\n\n","category":"function"},{"location":"index.html#DASopt.optim_wrap","page":"DASopt.jl","title":"DASopt.optim_wrap","text":"x, val = optim_wrap(f, x0, mapin;\nnrounds=3,\noptfunc=NelderMead(),\nsense = :Max,\noptions = Optim.Options(),\nn_starts = 0)\n\nArguments\n\nf is a nonlinear func to optimize\nx0 is an initial point. Instead of being a vector, x0 can be a generator, like ()->rand(3)\nmapin is a function applied to things like x to put in range.\nWe run for nrounds, with a mapinat the end of each to polish.\nThe n_starts option then tells us to start from the best of n_startsruns.\n\n\n\n\n\n","category":"function"},{"location":"index.html#DASopt.optim_wrap_many","page":"DASopt.jl","title":"DASopt.optim_wrap_many","text":"x, val = optim_wrap_many(f, x0, mapin; n = Inf, t_lim = Inf,\n    nrounds=3,\n    optfunc=NelderMead(),\n    sense = :Max,\n    options = Optim.Options(),\n    n_starts = 0,\n    par_batch = 0)\n\nval, best = optim_wrap_many(f, x0fun, mapin, nruns;\nnrounds, optfunc, maxevals, sense,\nfile=[])\n\nCall optim_wrap inside try_many. Kwargs come from both. At least one of n or t_lim must be set.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Other-optimization-heuristics","page":"DASopt.jl","title":"Other optimization heuristics","text":"","category":"section"},{"location":"index.html","page":"DASopt.jl","title":"DASopt.jl","text":"popevolve","category":"page"},{"location":"index.html#DASopt.popevolve","page":"DASopt.jl","title":"DASopt.popevolve","text":"opt = popevolve(f, x0, tlim; n = 10, mapin = identity)\n\nGenerates and evolves a population of potential solutions to minimize the function f.\n\nn is the number of populations elements\ntlim the time limit in seconds\n\nThe return, opt, has a couple of fields:\n\nminimizer: the best solution\nminimum: the value of it\npop: the population at the end\n\n\n\n\n\n","category":"function"}]
}
