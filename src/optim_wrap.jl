
"""
    x, val = optim_wrap(f, x0 / gen, mapin=identity;
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options(),
    autodiff = :finite,
    n_starts = 0)

A wrapper for `Optim`.  
Adds a few features that I find helpful, especially when I want to optimize over a manifold or odd parameter space.
The function `mapin` should take an aribtrary vector (or matrix) input and map it to the space of interest.
`mapin` will always be applied before `f`.

As `mapin` can do strange things to the vector, `Optim` might not be working in the right parameter space.
For this reason, it is helpful to occasionally stop optim, apply `mapin` to the current optimum,
and then restart `Optim` from that point.
This code does this `nrounds` times.
If it seems unnecessary, say if `mapin = identity`, then set `nrounds=1`.

As `Optim` can run for a while, we might be able to improve it by starting from the best of many inputs.
If `n_starts > 1`, the code will call `gen` to generate `n_starts` and then start `Optim` from the best of these.

# Arguments
- `f` is a nonlinear func to optimize
- `x0` is an initial point. Instead of being a vector, it can be a generator like `()->rand(3)`
- `mapin` is a function applied to things like `x` to put in range.
- We run for `nrounds`, with a `mapin `at the end of each to polish.
- The `n_starts` option then tells us to start from the best of `n_starts`runs.
- `optfunc` is the name of an optimizer that Optim uses.
- `options` are options for Optim, with the default generated by `Optim.Options()`
- `autodiff` is passed to Optim. The default is `:finite` when you want it, you want `:forward`.
"""
function optim_wrap(f, x0::Array, mapin=identity;
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options(),
    autodiff = :finite)

    @assert sense==:Max || sense==:Min

    if sense == :Max
        sgn = -1
        comp = >
    else
         sgn = 1
        comp = <
    end

    x0 = mapin(x0)
    fixed_f(z) = f(mapin(z))
    f_opt(z) = sgn*fixed_f(z)

    local val
    for i in 1:nrounds
        opt = Optim.optimize(f_opt, x0, optfunc , options; autodiff)
        best = opt.minimizer
        val = fixed_f(best)
        x0 = mapin(best)
    end

    return x0, val
end

function optim_wrap(f, gen::Function, mapin=identity;
    nrounds=3,
    optfunc=NelderMead(),
    sense = :Max,
    options = Optim.Options(),
    autodiff = :finite,
    n_starts = 0)

    fixed_f(z) = f(mapin(z))

    if n_starts > 1 
        x0, _  = try_many(fixed_f, gen, sense, n_tries = n_starts, verbosity=0)
    else
        x0 = gen()
    end 

    optim_wrap(f, x0, mapin;
        nrounds,
        optfunc,
        sense,
        options,
        autodiff)
end




"""
    x, val = optim_wrap_many(f, x0, mapin=identity; n_tries = Inf, t_lim = Inf,
        stop_val, 
        nrounds=3,
        optfunc=NelderMead(),
        autodiff = :finite,
        sense = :Max,
        options = Optim.Options(),
        n_starts = 0,
        par_batch = 0,
        threads = 0,
        stop_val = Inf for -Inf depending on sense)

    val, best = optim_wrap_many(f, x0fun, mapin, n_tries;
    nrounds, optfunc, maxevals, sense,
    file=[])

Call `optim_wrap` inside `try_many`. Kwargs come from both.
At least one of `n_tries` or `t_lim` must be set.
"""
function optim_wrap_many(f::Function, gen::Function, mapin=identity;  n_tries = Inf, t_lim = Inf,
    file_base = "",
    verbose = false,
    verbosity = 1 + verbose,
    seed = false,
    local_rng = false,
    nrounds=3,
    optfunc=NelderMead(),
    autodiff = :finite,
    sense = :Max,
    options = Optim.Options(),
    n_starts = 0,
    par_batch = 0,
    threads = 0,
    stop_val = sense == :Max ? Inf : -Inf)

    if t_lim < Inf
        tdo = Dict(fn=>getfield(options, fn) for fn âˆˆ fieldnames(typeof(options)))
        tdo[:time_limit] = t_lim
        options = Optim.Options(;tdo...)
    end

    fsub(x) = optim_wrap(f, gen, mapin;
        nrounds,
        optfunc,
        sense,
        options,
        autodiff,
        n_starts)

    # if t_lim, put that into options

    return try_many_trans(fsub, ()->Nothing, sense, n_tries = n_tries, t_lim = t_lim,
        file_base = file_base,
        verbosity = verbosity,
        seed = seed,
        local_rng = local_rng,
        par_batch = par_batch,
        threads = threads,
        stop_val = stop_val)


end

mutable struct EveryN
    n::Int
    i::Int
end

"""
    cnt = EveryN(n)

Every nth time `cnt()` is called it returns a 1. Otherwise it is 0.
"""
EveryN(n) = EveryN(n, 0)

function (cnt::EveryN)()
    cnt.i += 1
    if cnt.i == cnt.n
        cnt.i = 0
    end
    cnt.i == 0 ? 1 : 0
end

mutable struct EveryTic
    interval::Float64
    tbase::Float64
end

"""
    cnt = EveryTic(s)

cnt() will return 1 if the last time it returned 1 was at least `s` seconds ago.
Otherwise a 0.
"""
EveryTic(s) = EveryTic(s, time())

function (cnt::EveryTic)()
    out = 0
    t = time()
    if t > cnt.tbase + cnt.interval
        cnt.tbase = t
        out = 1
    end
    return out
end



# note t is in seconds
optim_tlim(t) = Optim.Options(iterations=typemax(Int),time_limit=t)